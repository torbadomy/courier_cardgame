<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å–®ç‹ä¹‹çˆ­ï¼šçµ•å‘½å¤–é€ (10å›åˆæ¥µé€Ÿç‰ˆ)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: "Microsoft JhengHei", sans-serif;
    }
    canvas {
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
<script>
/**
 * å–®ç‹ä¹‹çˆ­ï¼šçµ•å‘½å¤–é€ - 10å›åˆæ¥µé€Ÿç‰ˆ
 * ä¿®æ”¹ï¼šå¥§å®¢æ¶ˆè€—3/å ±é…¬150
 */

// --- éŠæˆ²è®Šæ•¸ ---
let gameState = "START"; 
const MAX_TURNS = 10; 
let player = {
  hp: 50,       
  maxHp: 50,    
  energy: 5,   
  maxEnergy: 5,
  money: 0,    
  stars: 5.0    
};

let deck = [];
let hand = [];
let discardPile = [];
let maxHandSize = 5;
let turnCount = 1;
let logs = [];
let animations = []; 

// UI è¨­å®š
let cardWidth = 120;
let cardHeight = 170;
let uiColor = {
  bg: [50, 50, 55], 
  panel: [30, 30, 30],
  accent: [0, 255, 150], 
  danger: [255, 80, 80], 
  text: [240, 240, 240]
};

// æŒ‰éˆ•ä½ç½®é…ç½® (å³ä¸Šè§’)
const btnConfig = {
  w: 120,
  h: 50,
  x: 800 - 130, 
  y: 15
};

// --- å¡ç‰Œè³‡æ–™åº« ---
const CARD_DATA = [
  // è¨‚å–®é¡
  { id: 1, name: "ä¸€æ¯çå¥¶", type: "ORDER", cost: 1, value: 30, desc: "ç°¡å–®è¼•é¬†ï¼Œ\nè³ºé»é›¶ç”¨éŒ¢ã€‚", color: [0, 200, 100] },
  { id: 2, name: "ç‚¸é›æ¡¶å…¨å®¶é¤", type: "ORDER", cost: 2, value: 70, desc: "å‘³é“å¾ˆé¦™ï¼Œ\nå°å¿ƒåˆ¥å·åƒã€‚", color: [0, 180, 100] },
  
  // é¢±é¢¨å¤© $200
  { id: 3, name: "é¢±é¢¨å¤©ç«é‹", type: "ORDER", cost: 4, value: 200, desc: "å¯Œè²´éšªä¸­æ±‚ï¼\nè‹¥å¤±æ•—ä»£åƒ¹æ…˜ç—›ã€‚", color: [255, 215, 0] },
  
  // [ä¿®æ”¹] å¥§å®¢: æ¶ˆè€—3 / å ±é…¬150
  { id: 4, name: "å¥§å®¢çš„è¨‚å–®", type: "ORDER", cost: 3, value: 150, desc: "éŒ¢å¾ˆå¤š...\nä½†é€å®Œè»Šæ³-10ã€‚", effect: "DMG_10", color: [150, 100, 50] },

  // è¡Œå‹•é¡
  { id: 5, name: "é‘½è»Šç¸«", type: "ACTION", cost: 0, value: 0, desc: "å±•ç¾é«˜è¶…æŠ€è¡“ã€‚\né«”åŠ› +2", effect: "ENERGY_2", color: [50, 150, 255] },
  { id: 6, name: "å–è »ç‰›", type: "ACTION", cost: 0, value: 0, desc: "ç´¯äº†å°±å–ã€‚\né«”åŠ› +3ï¼Œè»Šæ³ -5", effect: "ENERGY_3_DMG_5", color: [50, 150, 255] },
  { id: 7, name: "ç°¡æ˜“ç¶­ä¿®", type: "ACTION", cost: 3, value: 0, desc: "é›¶ä»¶æ¼²åƒ¹äº†ã€‚\nè€—3é«”ï¼Œè»Šæ³+15", effect: "HEAL_15", color: [200, 200, 200] }, 
  { id: 8, name: "ç´…ç‡ˆå³è½‰", type: "ACTION", cost: 0, value: 0, desc: "è­¦å¯Ÿæ²’çœ‹åˆ°ï¼\næŠ½ 2 å¼µç‰Œ", effect: "DRAW_2", color: [255, 100, 100] },
];

// --- p5.js ä¸»ç¨‹å¼ ---

function setup() {
  createCanvas(800, 600);
  textAlign(CENTER, CENTER);
  initGame();
}

function draw() {
  background(uiColor.bg);
  
  if (gameState === "START") {
    drawStartScreen();
  } else if (gameState === "PLAY") {
    drawGameUI();
    drawHand();
    drawAnimations();
    checkHover();
  } else if (gameState === "GAMEOVER") {
    drawGameOver();
  }
}

function mousePressed() {
  if (gameState === "START") {
    gameState = "PLAY";
    startTurn();
  } else if (gameState === "GAMEOVER") {
    initGame();
    gameState = "START";
  } else if (gameState === "PLAY") {
    // æª¢æŸ¥é»æ“Šå¡ç‰Œ
    for (let i = hand.length - 1; i >= 0; i--) {
      let c = hand[i];
      if (isMouseOverCard(c.x, c.y, cardWidth, cardHeight)) {
        playCard(i);
        return;
      }
    }
    
    // æª¢æŸ¥é»æ“Šã€ŒçµæŸå›åˆã€æŒ‰éˆ•
    if (isMouseOverBtn(btnConfig.x, btnConfig.y, btnConfig.w, btnConfig.h)) {
      endTurn();
    }
  }
}

// --- éŠæˆ²é‚è¼¯ ---

function initGame() {
  player = { hp: 50, maxHp: 50, energy: 5, maxEnergy: 5, money: 0, stars: 5.0 };
  deck = [];
  hand = [];
  discardPile = [];
  turnCount = 1;
  logs = ["--- å¤–é€é–‹å§‹ ---", `ç›®æ¨™ï¼šæ’é ${MAX_TURNS} å›åˆï¼`];
  createDeck();
  shuffleDeck();
}

function createDeck() {
  for (let i = 0; i < 15; i++) {
    let cardTemplate = random(CARD_DATA);
    if (random() > 0.6) cardTemplate = CARD_DATA[0]; 
    deck.push({ ...cardTemplate, uid: i }); 
  }
}

function shuffleDeck() {
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
}

function startTurn() {
  player.energy = player.maxEnergy; 
  addLog(`--- Round ${turnCount} ---`);
  
  while (hand.length < maxHandSize) {
    if (deck.length === 0) {
      if (discardPile.length === 0) break;
      deck = [...discardPile];
      discardPile = [];
      shuffleDeck();
      addLog("ç‰Œåº«é‡æ´—ï¼");
    }
    hand.push(deck.pop());
  }
  
  arrangeHand();
}

function arrangeHand() {
  let startX = (width - (hand.length * (cardWidth + 10))) / 2 + cardWidth/2;
  for (let i = 0; i < hand.length; i++) {
    hand[i].x = startX + i * (cardWidth + 10);
    hand[i].y = height - 120;
    hand[i].targetY = height - 120;
  }
}

function playCard(index) {
  let card = hand[index];
  
  if (player.energy < card.cost) {
    addLog("é«”åŠ›ä¸è¶³ï¼", "red");
    createAnimation("é«”åŠ›ä¸è¶³!", mouseX, mouseY, [255, 50, 50]);
    return;
  }
  
  player.energy -= card.cost;
  
  if (card.type === "ORDER") {
    player.money += card.value;
    createAnimation(`+$${card.value}`, width/2, height/2 - 50, [255, 215, 0]);
    addLog(`å®Œæˆï¼š${card.name} (+$${card.value})`);
    if (card.effect === "DMG_10") {
        player.hp -= 10;
        addLog("é‡åˆ°å¥§å®¢ï¼Œå¿ƒæƒ…å—æ -10è»Šæ³");
    }
  } else if (card.type === "ACTION") {
    if (card.effect === "ENERGY_2") {
        player.energy += 2;
        addLog("é‘½è»Šç¸«æˆåŠŸï¼é«”åŠ› +2");
    } else if (card.effect === "ENERGY_3_DMG_5") {
        player.energy += 3;
        player.hp -= 5;
        addLog("å–äº†è »ç‰›ï¼é«”åŠ›+3 è»Šæ³-5");
    } else if (card.effect === "HEAL_15") { 
        player.hp = Math.min(player.maxHp, player.hp + 15);
        addLog("å‹‰å¼·ä¿®å¥½äº†ã€‚è»Šæ³ +15");
    } else if (card.effect === "DRAW_2") {
        drawCard(2);
        addLog("é•è¦è¶…è»Šï¼æŠ½2å¼µç‰Œ");
    }
  }
  
  discardPile.push(card);
  hand.splice(index, 1);
  arrangeHand();
  
  if (player.hp <= 0) {
    gameState = "GAMEOVER";
  }
}

function drawCard(num) {
    for(let i=0; i<num; i++){
        if(hand.length < maxHandSize + 2) { 
             if (deck.length === 0) {
                deck = [...discardPile];
                discardPile = [];
                shuffleDeck();
            }
            if (deck.length > 0) hand.push(deck.pop());
        }
    }
    arrangeHand();
}

function endTurn() {
  triggerRoadEvent();
  
  // æª¢æŸ¥æ˜¯å¦æ­»äº¡
  if (player.hp <= 0) {
    gameState = "GAMEOVER";
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦åˆ°é”10å›åˆ
  if (turnCount >= MAX_TURNS) {
    gameState = "GAMEOVER"; 
    return;
  }
  
  turnCount++;
  while(hand.length > 0) {
      discardPile.push(hand.pop());
  }
  
  startTurn();
}

function triggerRoadEvent() {
    let eventRoll = random();
    let damage = 0;
    let msg = "";
    
    if (eventRoll < 0.3) {
        msg = "å¹³å®‰ç„¡äº‹çš„ä¸€å›åˆã€‚";
    } else if (eventRoll < 0.6) {
        damage = 10;
        msg = "ä¸‰å¯¶é–‹è»Šé–€ï¼æ‘”è»Š (è»Šæ³-10)";
    } else if (eventRoll < 0.8) {
        damage = 20;
        msg = "æš´é›¨è¦–ç·šæ¨¡ç³Šæ‰“æ»‘ (è»Šæ³-20)";
    } else {
        damage = 5;
        player.money = Math.max(0, player.money - 50);
        msg = "è­¦å¯Ÿé–‹å–®ï¼ç½°æ¬¾$50 (è»Šæ³-5)";
    }
    
    player.hp -= damage;
    addLog(msg, "orange");
    if(damage > 0) createAnimation(`-${damage} HP`, width/2, height/2, [255, 50, 50]);
}

// --- ç¹ªåœ–å‡½æ•¸ ---

function drawStartScreen() {
  fill(0, 150);
  rect(0, 0, width, height);
  
  fill(uiColor.accent);
  textSize(60);
  textStyle(BOLD);
  text("å–®ç‹ä¹‹çˆ­", width/2, height/2 - 60);
  
  fill(255);
  textSize(30);
  textStyle(NORMAL);
  text("10å›åˆæ¥µé€Ÿç‰ˆ", width/2, height/2);
  
  textSize(20);
  fill(200);
  text(`ç›®æ¨™ï¼šæ´»é ${MAX_TURNS} å›åˆä¸¦è³ºå¤§éŒ¢`, width/2, height/2 + 60);
  text("é»æ“Šç•«é¢é–‹å§‹", width/2, height/2 + 100);
}

function drawGameOver() {
  fill(0, 220);
  rect(0, 0, width, height);
  
  let title = "";
  let colorVal = [255, 255, 255];
  
  if (player.hp <= 0) {
      title = "è»Šæ¯€äººäº¡ï¼";
      colorVal = uiColor.danger;
  } else {
      title = "å¹³å®‰å›å®¶ï¼";
      colorVal = uiColor.accent;
  }
  
  fill(colorVal);
  textSize(60);
  textStyle(BOLD);
  text(title, width/2, height/2 - 50);
  
  fill(255);
  textSize(30);
  textStyle(NORMAL);
  text(`æœ€çµ‚æ¥­ç¸¾: $${player.money}`, width/2, height/2 + 30);
  
  // è©•åƒ¹é‚è¼¯ (æ ¹æ“š10å›åˆèª¿æ•´æ¨™æº–)
  let rank = "C";
  if (player.hp > 0) {
      if (player.money > 800) rank = "S (å–®ç‹)"; 
      else if (player.money > 500) rank = "A (å„ªé¸)";
      else if (player.money > 300) rank = "B (æ™®é€š)";
  } else {
      rank = "F (å ±å»¢)";
  }
  
  text(`è©•åƒ¹: ${rank}`, width/2, height/2 + 70);
  
  textSize(20);
  fill(200);
  text("é»æ“Šç•«é¢é‡æ–°é–‹å§‹", width/2, height/2 + 140);
}

function drawGameUI() {
  // é ‚éƒ¨ç‹€æ…‹åˆ—èƒŒæ™¯
  fill(uiColor.panel);
  noStroke();
  rect(0, 0, width, 80);
  
  // æ•¸æ“šé¡¯ç¤º
  textAlign(LEFT, CENTER);
  textSize(20);
  
  // éŒ¢
  fill(255, 215, 0);
  text(`ğŸ’° $${player.money}`, 30, 40);
  
  // è¡€é‡æ¢
  fill(200);
  text("è»Šæ³", 180, 25);
  fill(50);
  rect(180, 45, 150, 15, 5);
  let hpRatio = player.hp / player.maxHp;
  if(hpRatio > 0.5) fill(uiColor.accent);
  else if(hpRatio > 0.25) fill(255, 165, 0);
  else fill(uiColor.danger);
  rect(180, 45, Math.max(0, map(player.hp, 0, player.maxHp, 0, 150)), 15, 5);
  
  fill(255);
  textSize(14);
  text(`${Math.max(0, player.hp)}/${player.maxHp}`, 230, 53);
  
  // é«”åŠ›æ¢
  textSize(20);
  fill(200);
  text("é«”åŠ›", 380, 25);
  for(let i=0; i<player.maxEnergy; i++) {
      if(i < player.energy) fill(50, 150, 255);
      else fill(80);
      ellipse(390 + i * 25, 52, 18, 18);
  }
  
  // å›åˆæ•¸é¡¯ç¤º (10å›åˆç‰ˆ)
  textAlign(RIGHT, CENTER);
  fill(255);
  textSize(22);
  // æœ€å¾Œ2å›åˆè®Šç´…å­—
  if(turnCount >= 8) fill(255, 100, 100); 
  text(`Round ${turnCount} / ${MAX_TURNS}`, width - 140, 40);
  
  // Log å€å¡Š
  fill(0, 100);
  stroke(100);
  rect(width/2 - 200, 100, 400, 120, 5);
  noStroke();
  textAlign(CENTER, TOP);
  textSize(16);
  let logY = 110;
  for(let i = logs.length - 1; i >= Math.max(0, logs.length - 4); i--) {
     let colorVal = logs[i].includes("è»Šæ³") || logs[i].includes("ä¸è¶³") ? [255, 100, 100] : [220, 220, 220];
     fill(colorVal);
     text(logs[i], width/2, logY);
     logY += 25;
  }
  
  // çµæŸå›åˆæŒ‰éˆ•
  let btnX = btnConfig.x;
  let btnY = btnConfig.y;
  let btnW = btnConfig.w;
  let btnH = btnConfig.h;
  
  let isHover = isMouseOverBtn(btnX, btnY, btnW, btnH);
  fill(isHover ? [255, 100, 100] : [200, 50, 50]);
  rect(btnX, btnY, btnW, btnH, 10);
  
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(20);
  text("çµæŸå›åˆ", btnX + btnW/2, btnY + btnH/2);
}

function drawHand() {
  rectMode(CENTER);
  for (let i = 0; i < hand.length; i++) {
    let c = hand[i];
    let isHover = isMouseOverCard(c.x, c.y, cardWidth, cardHeight);
    
    let yPos = isHover ? c.y - 30 : c.y;
    
    push();
    translate(c.x, yPos);
    
    // å¡èƒŒ
    fill(0, 100);
    noStroke();
    rect(5, 5, cardWidth, cardHeight, 10);
    
    // å¡é¢
    fill(250);
    stroke(c.color);
    strokeWeight(isHover ? 4 : 2);
    rect(0, 0, cardWidth, cardHeight, 10);
    
    // æ¨™é¡Œ
    fill(c.color);
    noStroke();
    rect(0, -cardHeight/2 + 20, cardWidth, 40, 10, 10, 0, 0);
    
    fill(255);
    textSize(18);
    textStyle(BOLD);
    textAlign(CENTER, CENTER);
    text(c.name, 0, -cardHeight/2 + 20);
    
    // è²»ç”¨
    fill(50, 100, 255);
    ellipse(-cardWidth/2 + 15, -cardHeight/2 + 15, 25, 25);
    fill(255);
    textSize(16);
    text(c.cost, -cardWidth/2 + 15, -cardHeight/2 + 16);
    
    // å¦‚æœæ˜¯è¨‚å–®ï¼Œé¡¯ç¤ºåƒ¹æ ¼
    if (c.type === "ORDER") {
        fill(200, 150, 0); // é‡‘è‰²é™°å½±
        textSize(32);
        textStyle(BOLD);
        text(`$${c.value}`, 2, 5); 
        fill(255, 215, 0); // é‡‘è‰²
        text(`$${c.value}`, 0, 3);
    }
    
    // æè¿°
    fill(50);
    textSize(14);
    textStyle(NORMAL);
    let descY = c.type === "ORDER" ? 40 : 10; 
    text(c.desc, 0, descY, cardWidth - 20, 80);
    
    // é¡åˆ¥
    textSize(12);
    fill(100);
    text(c.type === "ORDER" ? "è¨‚å–®" : "è¡Œå‹•", 0, cardHeight/2 - 15);
    
    pop();
  }
  rectMode(CORNER);
}

function createAnimation(txt, x, y, col) {
  animations.push({
    txt: txt,
    x: x,
    y: y,
    alpha: 255,
    color: col
  });
}

function drawAnimations() {
  for (let i = animations.length - 1; i >= 0; i--) {
    let a = animations[i];
    fill(a.color[0], a.color[1], a.color[2], a.alpha);
    stroke(0, a.alpha);
    strokeWeight(2);
    textSize(24);
    text(a.txt, a.x, a.y);
    a.y -= 1.5; 
    a.alpha -= 5; 
    if (a.alpha <= 0) animations.splice(i, 1);
  }
}

function checkHover() {
  cursor(ARROW);
  for (let c of hand) {
    if (isMouseOverCard(c.x, c.y, cardWidth, cardHeight)) {
      cursor(HAND);
      return;
    }
  }
  if (isMouseOverBtn(btnConfig.x, btnConfig.y, btnConfig.w, btnConfig.h)) {
     cursor(HAND);
  }
}

function isMouseOverCard(x, y, w, h) {
  if (gameState !== "PLAY") return false;
  return mouseX > x - w/2 && mouseX < x + w/2 &&
         mouseY > y - h/2 && mouseY < y + h/2;
}

function isMouseOverBtn(x, y, w, h) {
  if (gameState !== "PLAY") return false;
  return mouseX > x && mouseX < x + w &&
         mouseY > y && mouseY < y + h;
}

function addLog(msg, colorType) {
    logs.push(msg);
    if(logs.length > 6) logs.shift();
}

</script>
</body>
</html>